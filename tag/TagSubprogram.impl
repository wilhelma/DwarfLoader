//
// Created by wilhelma on 12/23/16.
//

#ifndef DWARFLOADER_TAGSUBPROGRAM_H
#define DWARFLOADER_TAGSUBPROGRAM_H

#include "./TagGeneric.h"
#include "../entities/Routine.h"
#include "../include/Type.h"
#include "../include/DwarfReader.h"

#include "../include/Context.h"

namespace pcv {
namespace dwarf {

template <> struct TagHandler<DW_TAG_subprogram> {
  static bool handle(Context &ctxt)
  {
    if (hasAttr(ctxt.die, DW_AT_declaration) &&
       !hasAttr(ctxt.die, DW_AT_artificial)) {
      char *rtnName{nullptr};
      Dwarf_Unsigned fileNo{}, lineNo{};
      Dwarf_Off off{};

      if (dwarf_diename(ctxt.die, &rtnName, nullptr) != DW_DLV_OK) throw DwarfError("diename");
      if (dwarf_die_CU_offset(ctxt.die, &off, nullptr) != DW_DLV_OK) throw DwarfError("cu_offset");
      getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_file, &fileNo);
      getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_line, &lineNo);

      ctxt.routines.emplace_back(
          std::unique_ptr<Routine> {
              new Routine(rtnName,
                          *ctxt.currentImage,
                          *ctxt.currentNamespace,
                          ctxt.srcFiles[fileNo-1],
                          lineNo,
                          off)
          }
      );

      ctxt.currentRoutine = ctxt.routines.back().get();

      if (ctxt.currentClass != nullptr) {
        ctxt.currentClass->methods.push_back( ctxt.currentRoutine );
      }

    }

    return false;  // continue
  }
};

}  // namespace dwarf
}  // namespace pcv

#endif //DWARFLOADER_TAGSUBPROGRAM_H
