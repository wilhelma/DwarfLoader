//
// Created by wilhelma on 12/23/16.
//

#ifndef DWARFLOADER_TAGSUBPROGRAM_H
#define DWARFLOADER_TAGSUBPROGRAM_H

#include "./TagGeneric.h"
#include "../entities/Routine.h"
#include "../include/Type.h"
#include "../include/DwarfReader.h"

#include "../include/Context.h"

namespace pcv {
namespace dwarf {

template <> struct TagHandler<DW_TAG_subprogram> {
  static bool handle(Context &ctxt)
  {
    if (hasAttr(ctxt.die, DW_AT_name) &&
        hasAttr(ctxt.die, DW_AT_decl_file) &&
        !hasAttr(ctxt.die, DW_AT_artificial)) {
      char *rtnName{nullptr};
      Dwarf_Unsigned fileNo{}, lineNo{};
      Dwarf_Off off{};

      if (dwarf_diename(ctxt.die, &rtnName, nullptr) != DW_DLV_OK) throw DwarfError("diename");
      if (dwarf_dieoffset(ctxt.die, &off, nullptr) != DW_DLV_OK) throw DwarfError("offset");
      getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_file, &fileNo);
      getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_line, &lineNo);

      auto rtn = std::unique_ptr<Routine> {
              new Routine(rtnName,
                          *ctxt.currentImage,
                          *ctxt.currentNamespace,
                          ctxt.currentClass.empty() ? nullptr : ctxt.currentClass.top(),
                          ctxt.srcFiles[fileNo-1],
                          lineNo,
                          off) };

      ctxt.addRoutine(off, std::move(rtn));

      if (!ctxt.currentClass.empty())
        ctxt.currentClass.top()->methods.push_back( ctxt.routines.back().get() );

      ctxt.currentRoutine = ctxt.routines.back().get();
    }

    return false;  // continue
  }
  static bool handleDuplicate(Context &ctxt)
  {
    auto rtn = ctxt.getRoutine(ctxt.duplicate);
    if (rtn)
      ctxt.currentRoutine = rtn;

    return false;  // continue
  }
};

}  // namespace dwarf
}  // namespace pcv

#endif //DWARFLOADER_TAGSUBPROGRAM_H
