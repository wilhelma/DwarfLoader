//
// Created by wilhelma on 12/23/16.
//

#ifndef DWARFLOADER_TAGMEMBER_H
#define DWARFLOADER_TAGMEMBER_H

#include "./TagGeneric.h"
#include "../include/DwarfHelper.h"

namespace pcv {
namespace dwarf {

std::string demangle(const char *);

class Context;

template<>
struct TagHandler<DW_TAG_member> {
  static bool handle(Context &ctxt)
  {
    if (!hasAttr(ctxt.die, DW_AT_artificial)) {
      Dwarf_Off off;
      dwarf_dieoffset(ctxt.die, &off, nullptr);
      if (ctxt.currentClass.empty()) throw DwarfError("No class for member");
      if (getPtrOff(ctxt.dbg, jump(ctxt.dbg, ctxt.die, DW_AT_type), &off)) {
        ctxt.addComposition(ctxt.currentClass.top()->offset, off);
      } else { // member variable
        char *varName{nullptr};
        if (dwarf_diename(ctxt.die, &varName, nullptr) == DW_DLV_OK) {
          if (dwarf_dieoffset(ctxt.die, &off, nullptr) != DW_DLV_OK) throw DwarfError("off");

          Dwarf_Unsigned file{}, line{};
          getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_file, &file);
          getAttrUint(ctxt.dbg, ctxt.die, DW_AT_decl_line, &line);

          ctxt.variables.emplace_back(
              std::unique_ptr<Variable> {
                  new Variable(demangle(varName),
                               *ctxt.currentImage,
                               *ctxt.currentNamespace,
                               ctxt.currentClass.top(),
                               ctxt.srcFiles[file - 1],
                               line,
                               off)
              }
          );
          ctxt.currentClass.top()->members.push_back(ctxt.variables.back().get());
        }
      }

      return true;  // do not investigate further
    }
  }
  static bool handleDuplicate(Context &ctxt)
  {
    return false;
  }
};

}  // dwarf
}  // pcv


#endif //DWARFLOADER_TAGMEMBER_H
